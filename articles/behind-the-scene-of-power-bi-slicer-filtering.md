---
title: "DAX による動的制御とコンテキスト"
emoji: "📚"
type: "tech" # tech: 技術記事 / idea: アイデア
topics: ["DAX", "PowerBI"]
published: false
---

# はじめに

[前々回](https://zenn.dev/microsoft/articles/power-bi-slicer-filtering-1) と [前回](https://zenn.dev/microsoft/articles/power-bi-slicer-filtering-2) では、ビジュアル フィルターと DAX を組み合わせてスライサーの挙動を制御しました。本記事は、その裏側で効いている「フィルターコンテキスト」と `CALCULATE` の働きを、アンケート分析の例でコンパクトに整理します。

# TL;DR
- DAXは常に「現在のフィルターコンテキスト」で評価される。
- `CALCULATE` は「新しいフィルターを適用して式をその場で再計算」する。
- スライサーの可否判定DAXは「項目ごとに評価」され、かつ「どの列をスライサーに与えるか」で挙動が変わる。

---

# フィルターコンテキストの基礎

- 定義: 式が評価対象とするデータの絞り込み条件の集合（スライサー、ビジュアル/ページ/レポート フィルター、相互作用などが作る）。
- 例: アンケート結果に対して「部署=営業部」のスライサー（列: `部署[部署名]`）が選択されると、以降の DAX は営業部の回答だけを対象に動く。
- 参考: 行コンテキストは「今見ている行」の概念。フィルターコンテキストとは別物。

---

# CALCULATE と「その場の再計算」

`CALCULATE(<式>, <フィルター...>)` は、指定したフィルターを現在のコンテキストに課して「その状態で <式> を再評価」します。

```DAX
営業部の回答数 =
CALCULATE(
  COUNTROWS(アンケート結果),
  部署[部署名] = "営業部"
)
```

- 元々どんな選択があっても、上記は「部署=営業部」を適用して再計算します。
- よく使う仲間
  - `ALL(テーブル/列)`: 既存フィルターを解除して計算。
  - `ALLSELECTED(テーブル/列)`: ユーザーの明示的な選択は保持しつつ計算（後述）。

---

# 実装パターン

## 1) 条件制御（部署が選ばれたら年齢スライサーを無効化）

```DAX
年齢スライサー表示フラグ =
VAR SelectedFlag = ISFILTERED(部署[部署名])
RETURN IF(SelectedFlag, 0, 1)
```

- 使い方: 年齢スライサーのビジュアルレベル フィルターで「年齢スライサー表示フラグ = 1」を条件に設定。

補足: ISFILTERED
- 指定列に何らかのフィルターがかかっていれば TRUE。スライサーの選択や他ビジュアルからの絞り込みを検知するのに便利。

## 2) 動的リスク判定（件数が閾値未満なら非表示）

```DAX
割り出しリスクフラグ =
VAR 件数 =
  CALCULATE(
    COUNTROWS(アンケート結果),
    ALLSELECTED(アンケート結果)
  )
VAR 閾値 = 5
RETURN IF(件数 < 閾値, 0, 1)
```

- 使い方: 対象スライサーにビジュアルレベル フィルターとして「割り出しリスクフラグ = 1」を設定。

補足: ALLSELECTED
- ユーザーが明示的に選んだ選択（スライサー、相互作用）は尊重しつつ、現在のビジュアルの一時的な絞り込みを外して集計するのに使える。`ALL` はすべてのフィルターを外す点が異なる。

---

# スライサーのフィルターは「項目ごとに評価」される

スライサーに DAX ベースの可否判定（例: 上記のフラグ列）をフィルターとして設定すると、スライサーの各項目（例: 年齢の各区分）ごとに式が評価され、表示可否が決まります。

- メリット: 項目単位で動的に出し分けできる。
- 注意: 評価回数が増えるため複雑な式はパフォーマンスに影響。必要なら中間テーブルや事前集計で軽量化。

---

# スライサーに与える列の違いで挙動が変わる

同じ「部署」スライサーでも、どの列を使うかで結果が変わります。

- 次元テーブル（例: `部署[部署名]`）を使う場合
  - リレーションが正しければ、ユニークで整った一覧が表示され、選択は関係を通じて事実（`アンケート結果`）に伝播。
  - おすすめの基本形。データ整合性と見た目が安定。

- 事実テーブル（例: `アンケート結果[部署]`）を使う場合
  - 記録値がそのまま候補に。重複・表記揺れ・未定義値が表示されやすい。
  - 意図しない選択肢や集計のブレを招くため、原則は次元列の利用を推奨。

---

## よくある落とし穴とコツ

- スライサーは原則「次元テーブルのユニーク列」を使う。
- 閾値やルールはメジャー化・パラメータ化して一元管理。
- `ALL`/`ALLSELECTED`/`REMOVEFILTERS` の違いを把握して使い分け。
- パフォーマンスは「式の単純化」「列の低カーディナリティ化」「不要な依存の削減」で対処。

---

# まとめ

- DAXはフィルターコンテキストに従い、`CALCULATE` は新たなフィルターでその場再計算する。
- スライサーの可否判定は項目ごとに評価されるため、式の重さと列選定（次元か事実か）が効く。
- `ISFILTERED` と `ALLSELECTED` のポイントを押さえると、条件制御とリスク判定が設計しやすくなる。